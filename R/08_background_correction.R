#' Background-correct and export results
#' @param paths Character vector of paths to store intput, intermediary results, outputs...
#' @param FCS_export if "none", no FCS export. If "concatenated", export one FCS file with all the data. if "split", export the data in the result folder under the subfolder FCS, with each file corresponding to a (subsampled) input file. If "csv", export concatenated background-corrected data to CSV.
#' @param umap UMAP dimensionality reduction matrix of the Backbone data
#' @param annot annotation table generated by infinityFlow:::intialize()
#' @param verbose Verbosity

#' @importFrom utils read.csv
#' @importFrom utils write.csv
#' @importFrom flowCore write.FCS
#' @importFrom flowCore flowFrame
#' @noRd
correct_background <- function(
                            paths,
                            FCS_export,
                            chans=readRDS(file.path(paths["rds"],"chans.Rds")),
                            umap=readRDS(file.path(paths["rds"], "umap.Rds")),
                            annot=read.csv(paths["annotation"],sep=",",header=TRUE,stringsAsFactors=FALSE),
                            verbose=TRUE
                            ){

    if(verbose){
        message("Background correcting")
    }
    
    for(i in seq_len(nrow(annot))){
        iso <- match(annot[i,"isotype"], annot[, "file"])
        preds_marker <- list()
        preds_iso <- list()
        ns_out <- rep(0L, nrow(annot))
        for(j in seq_len(nrow(annot))){
            preds_marker <- c(preds_marker, list(h5read(paths["h5"], name = paste0("/predictions/raw/", j), index = list(NULL, i))))
            preds_iso <- c(preds_iso, list(h5read(paths["h5"], name = paste0("/predictions/raw/", j), index = list(NULL, iso))))
            ns_out[j] <- length(preds_marker[[j]])
        }
        preds_marker <- do.call(c, preds_marker)
        preds_iso <- do.call(c, preds_iso)
        ns_out <- c(1, ns_out)
        ns_out <- cumsum(ns_out)
        ## x <- preds_raw[[i]][,iso]
        ## y <- preds_raw[[i]][,file]
        residuals <- lm(preds_marker~preds_iso)$residuals
        ## intercept <- lm[1]
        ## slope <- lm[2]
        ## orthogonal_residuals <- (-slope*preds_iso+preds_marker-intercept)/sqrt(slope^2+1)
        ## preds_rawbgc[[i]][,file] <- orthogonal_residuals
        for(j in seq_len(nrow(annot))){
            h5write(obj = residuals[seq(ns_out[j], ns_out[j+1]-1)], file = paths["h5"], name = paste0("/predictions/background_corrected/", j), index = list(NULL, i))
            colnames <- h5readAttributes(file = paths["h5"], name = paste0("/predictions/raw/", j))$colnames
            colnames <- paste0(colnames, "_bgc")
            h5writeAttribute(attr = colnames, h5obj = paths["h5"], name = "colnames", h5loc = paste0("predictions/background_corrected/", j))
        }
    }
    
    ## ##################
    ## Exporting Phenograph / BGC / UMAP
    ## ##################

    if(verbose){
        message("\tTransforming background-corrected predictions. (Use logarithm to visualize)")
    }
    ## Preparing data for display using log transform

    ## Add re-scaled UMAP, PE_ID and export
    preds_concatenated <- list()
    umap_ranges <- apply(umap, 2, range)
    
    for(i in seq_len(nrow(annot))){
        preds <- h5read(file = paths["h5"], name = paste0("/predictions/raw/", i))
        preds <- 10^preds
        colnames(preds) <- h5readAttributes(file = paths["h5"], name = paste0("/predictions/background_corrected/", i))$colnames
                
        index <- list(
                which(h5read(file = paths["h5"], name = paste0("sampling/predictions/", i)) == 1L),
                NULL
        )
        backbone_data <- h5read(file = paths["h5"], name = paste0("/input/expression/", i), index = index)
        colnames(backbone_data) <- h5readAttributes(file = paths["h5"], name = paste0("/input/expression/", i))$colnames

        umap_i <- h5read(file = paths["h5"], name = paste0("/umap/backbone/", i))
        colnames(umap_i) = paste0("UMAP", 1:2)
        for(j in seq_len(ncol(umap_i))){
            umap_i[, j] <- (umap_i[, j] - umap_ranges[1, j])/(umap_ranges[2, j] - umap_ranges[1, j])*10000
        }
        preds <- cbind(
            backbone_data,
            preds,
            Exploratory_Ab_ID = i,
            umap_i
        )
        if("csv" %in% FCS_export){          
            if(verbose & i == 1){
                message("\t","Exporting as a concatenated CSV file")
            }
            write.table(
                preds,
                file = file.path(paths["output"], "results_background_corrected.csv"),
                row.names = FALSE,
                append = i != 1,
                col.names = i == 1,
                sep = ","
            )
        }

        if("split" %in% FCS_export){
            if(verbose & i == 1){
                message("\t","Exporting FCS files (1 per well)")
            }
            dir.create(file.path(paths["output"],"FCS_background_corrected","split"),showWarnings=FALSE,recursive=TRUE)
            FCS <- flowFrame(preds)
            FCS@parameters$desc <- as.character(FCS@parameters$desc)
            FCS@parameters$name <- as.character(FCS@parameters$name)
            FCS <- generate_description(FCS)
            invisible(
                write.FCS(
                    FCS,
                    filename = file.path(paths["output"], "FCS_background_corrected", "split", paste0(sub(".fcs","",annot[i, "file"]), "_target_", gsub("/", "-", annot[i, "target"]), ".fcs"))
                )
            )
        }
        if("concatenated" %in% FCS_export){
            preds_concatenated <- c(preds_concatenated, list(preds))
        }
    }

    if("concatenated" %in% FCS_export){
        if(verbose){
            message("\t","Exporting concatenated FCS file\n\t\t/!\\ Warning /!\\ - this may use a lot of RAM, consider 'split' exports")
        }
        dir.create(file.path(paths["output"], "FCS_background_corrected", "concatenated"), showWarnings = FALSE, recursive = TRUE)
        FCS <- flowFrame(do.call(rbind, preds_concatenated))
        FCS@parameters$desc <- as.character(FCS@parameters$desc)
        FCS@parameters$name <- as.character(FCS@parameters$name)
        FCS <- generate_description(FCS)
        invisible(write.FCS(FCS,filename=file.path(paths["output"],"FCS_background_corrected","concatenated","concatenated_results.fcs")))
    }

    invisible()
}
