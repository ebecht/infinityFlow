#' Transform FCS files
#' @description Backbone measurements use a common transformation across the whole dataset. Exploratory measurements are transformed well/file-wise.
#' @param yvar name of the exploratory measurement
#' @param paths Character vector of paths to store intput, intermediary results, outputs...
#' @param xp Logicle-transformed backbone expression matrix
#' @param chans vector of backbone channels' names
#' @param events.code vector of length nrow(xp) specifying from which well each event originates
#' @param annot annotation table generated by infinityFlow:::intialize()
#' @param verbose Verbosity
#' @importFrom utils read.table
#' @importFrom stats quantile
#' @importFrom flowCore logicleTransform inverseLogicleTransform
#' @importFrom rhdf5 h5read
#' @noRd
logicle_transform_input <- function(
                                    yvar,
                                    paths,
                                    chans=readRDS(file.path(paths["rds"],"chans.Rds")),
                                    transforms=readRDS(file.path(paths["rds"],"transforms.Rds")),
                                    annot=read.table(paths["annotation"],sep=",",header=TRUE,stringsAsFactors=FALSE),
                                    verbose=TRUE
                                    ){
    
    ## ##################
    ## Exporting transformed expression matrices
    ## ##################
    if(verbose){
        message("\tTransforming expression matrix")
    }

    for(i in seq_len(nrow(annot))){
        xp = h5read(file = paths["h5"], name = paste0("/input/expression/", i))
        colnames(xp) = h5readAttributes(file = paths["h5"], name = paste0("/input/expression/", i))$colnames
        for(chan in c(chans, yvar)){
            xp[, chan] = transforms[[chan]]$forward(xp[, chan])
        }
        h5write(obj = xp, file = paths["h5"], name = paste0("/input/expression_transformed/", i))
    }

    invisible()
}
